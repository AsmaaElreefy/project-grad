/*!

    Copyright 2011 Michael Phan-Ba

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 */

/** Module dependencies. */

var vows = require('vows')
  , assert = require('assert')
  , sinon = require('sinon');

/** Fixtures. */

// Replace AgentConnector with spy before loading connector
var agent = require('../../lib/connector/agent')
  , agentConnectorSpy = sinon.spy(agent, 'AgentConnector');

// Load connector with AgentConnector spy
var connector = require('../../lib/connector')
  , JsonConnector = connector.JsonConnector
  , merge = connector.merge;

function responseFactory(handler, callback) {
  var response = {
    statusCode: 200,
    method: 'GET',
    headers: {},
    setEncoding: sinon.stub(),
    on: sinon.stub()
  };

  handler(null, response);

  this.callback(null, response, callback);
}

function dataWrapper(response, callback) {
  var dataHandlers = []
    , endHandlers = [];

  response.on.args.forEach(function(args) {
    switch (args[0]) {
      case 'data':
        dataHandlers.push(args[1]);
        break;
      case 'end':
        endHandlers.push(args[1]);
        break;
    }
  });

  function end(data) {
    dataHandlers.forEach(function(fn) {
      if (data instanceof Array) {
        data.forEach(function(data) { fn(data) });
      } else {
        fn(data);
      }
    });
    endHandlers.forEach(function(fn) { fn() });
  }

  this.callback(null, response, end, callback);
}

function responseWrapper(topic) {
  return function(handler, callback) {
    var self = this, answer;

    responseFactory.call({
      callback: function(err, response, callback) {
        if (err) throw err;
        dataWrapper.call({
          callback: function(err, response, end, callback) {
            if (err) throw err;
            answer = topic.call(self, response, end, callback);
          }
        }, response, callback);
      }
    }, handler, callback);

    return answer;
  };
}

function behavesLikeRequest(options) {
  return {
    topic: function() {
      var callback = sinon.stub()
        , connector = { request: sinon.stub() }
        , jc = new JsonConnector({ connector: connector });

      if (!options) jc.request(callback);
      else jc.request(options, callback);

      this.callback(null, jc, options, callback);
    },
    'should call underlying connector.request()': function(err, jc, options, callback) {
      if (!options) assert.isTrue(jc.connector.request.calledOnce);
      else assert.isTrue(jc.connector.request.calledWith(options));
    },
    'callback()': {
      topic: function(jc, options, callback) {
        this.callback(null, jc.connector.request.getCall(0).args[1], callback);
      },
      'on error': {
        topic: function(handler, callback) {
          var error = {};
          handler(error);
          var answer = callback.calledWith(error);
          callback.reset();
          return answer;
        },
        'should pass error to callback': function(calledWithError) {
          assert.isTrue(calledWithError);
        }
      },
      'on response': {
        topic: responseFactory,
        'should set encoding to utf8': function(err, response, callback) {
          assert.isTrue(response.setEncoding.calledWith('utf8'));
        },
        'should assign data event handler': function(err, response, callback) {
          assert.isTrue(response.on.calledWith('data'));
        },
        'should assign end event handler': function(err, response, callback) {
          assert.isTrue(response.on.calledWith('end'));
        }
      },
      'on response with': {
        'JSON body': {
          topic: responseWrapper(function(response, end, callback) {
            end('{"message":"Hello World!"}');
            var answer = callback.args[0]; callback.reset();
            this.callback(null, answer, response);
          }),
          'should call callback with data': function(err, args, response) {
            assert.isFalse(!!args[0]);
            assert.deepEqual(args[1], { message: 'Hello World!' });
            assert.strictEqual(args[2], response);
          }
        },
        'chunking JSON body': {
          topic: responseWrapper(function(response, end, callback) {
            end(['{"m', 'essage":', '"Hello World', '!"}']);
            var answer = callback.args[0]; callback.reset();
            this.callback(null, answer, response);
          }),
          'should call callback with data': function(err, args, response) {
            assert.isFalse(!!args[0]);
            assert.deepEqual(args[1], { message: 'Hello World!' });
            assert.strictEqual(args[2], response);
          }
        },
        'sending empty body': {
          topic: responseWrapper(function(response, end, callback) {
            end();
            var answer = callback.args[0]; callback.reset();
            this.callback(null, answer, response);
          }),
          'should call callback with error': function(err, args, response) {
            assert.isTrue(!!args[0]);
            assert.isFalse(!!args[1]);
            assert.strictEqual(args[2], response);
          }
        },
        'sending binary body': {
          topic: responseWrapper(function(response, end, callback) {
            end(new Buffer([1, 2, 3, 4]).toString());
            var answer = callback.args[0]; callback.reset();
            this.callback(null, answer, response);
          }),
          'should call callback with error': function(err, args, response) {
            assert.isTrue(!!args[0]);
            assert.isFalse(!!args[1]);
            assert.strictEqual(args[2], response);
          }
        },
        'HEAD method': {
          topic: responseWrapper(function(response, end, callback) {
            response.method = 'HEAD';
            end();
            var answer = callback.args[0]; callback.reset();
            this.callback(null, answer, response);
          }),
          'should call callback with headers': function(err, args, response) {
            assert.isFalse(!!args[0]);
            assert.strictEqual(args[1], response.headers);
            assert.strictEqual(args[2], response);
          }
        }
      }
    }
  };
}

/** Vows tests. */

var suite = vows.describe('JsonConnector');

suite.addBatch({
  'constructor': {
    'with no options': {
      topic: function() {
        var connector = new JsonConnector()
          , call = agentConnectorSpy.getCall(0);
        agentConnectorSpy.reset();
        this.callback(null, connector, call);
      },
      'should create new AgentConnector': function(err, connector, call) {
        assert.strictEqual(connector.connector, call.thisValue);
      }
    },
    'when given options': {
      topic: function() {
        var options = {}
          , connector = new JsonConnector(options)
          , call = agentConnectorSpy.getCall(0);
        agentConnectorSpy.reset()
        this.callback(null, connector, call, options);
      },
      'should create new AgentConnector': function(err, connector, call, options) {
        assert.isTrue(call.calledWith(options));
        assert.strictEqual(connector.connector, call.thisValue);
      }
    },
    'when given connector': {
      topic: function() {
        var stub = {}
          , connector = new JsonConnector({ connector: stub });
        this.callback(null, connector, stub);
      },
      'should use given connector': function(err, connector, stub) {
        assert.strictEqual(connector.connector, stub);
      }
    }
  }
});

suite.addBatch({
  'request()': behavesLikeRequest(),
  'request() with options': behavesLikeRequest({})
});

suite.addBatch({
  'close()': {
    topic: function() {
      var stub = { close: sinon.stub() }
        , connector = new JsonConnector({ connector: stub });
      connector.close();
      return connector;
    },
    'should call underlying connector.close()': function(connector) {
      assert.isTrue(connector.connector.close.calledOnce);
    }
  }
});

suite.export(module);
