/*!

    Copyright 2011 Michael Phan-Ba

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 */

/** Module dependencies. */

var EventEmitter = require('events').EventEmitter
  , vows = require('vows')
  , assert = require('assert')
  , sinon = require('sinon')
  , http = require('http')
  , https = require('https');

var connector = require('../../lib/connector')
  , AgentConnector = connector.AgentConnector
  , merge = connector.merge;

/** Test fixtures. */

var defaultOptions = {
  agent: undefined,
  socket: http,
  maxSockets: 8,
  host: '127.0.0.1',
  port: undefined,
  path: '',
  query: undefined,
  hash: undefined,
  method: 'GET',
  headers: {
    'Host': '127.0.0.1',
    'Connection': 'close'
  },
  secure: false,
  auth: undefined
};

var testOptionsTemplate = {
  agent: undefined,
  socket: undefined,
  maxSockets: 2,
  host: 'example.com',
  port: 8888,
  path: '/proxy',
  query: {
    bool: true,
    int: 42,
    float: 42.0,
    string: 'Hello World!'
  },
  hash: 'test',
  method: 'POST',
  headers: {
    'Connection': 'close',
    'X-Test': 'true'
  },
  secure: true,
  auth: {
    username: 'root',
    password: 'xyzzy'
  }
};

var urlData = {
  protocol: 'https',
  auth: {
    username: 'user',
    password: 'pass'
  },
  hostname: 'host.com',
  port: '8080',
  pathname: '/p/a/t/h',
  query: {
    query: 'string'
  },
  hash: 'hash',
  url: 'https://user:pass@host.com:8080/p/a/t/h?query=string#hash',
  urlWithoutPassword: 'https://user@host.com:8080/p/a/t/h?query=string#hash',
  urlObject: {
    protocol: 'https:',
    auth: 'user:pass',
    hostname: 'host.com',
    port: '8080',
    pathname: '/p/a/t/h',
    query: { query: 'string' },
    hash: '#hash'
  },
  header: 'Basic dXNlcjpwYXNz',
  headerWithoutPassword: 'Basic dXNlcg=='
};

var testAuthHeader = 'Basic cm9vdDp4eXp6eQ==';

function shouldHaveOptions(setOptions) {
  var testAgent = {}
    , testSocket = {}

  testSocket.request = sinon.stub().returns(testSocket);

  testSocket.Agent = function(options) {
    merge(testAgent, options);
    return testAgent;
  };

  var testOptions = merge({}, testOptionsTemplate, {
    agent: testAgent,
    socket: testSocket,
  });

  var options = {}, noPass;

  setOptions.forEach(function(key) {
    switch (key) {
      case 'url':
        options.url = urlData.url;
        break;

      case 'urlWithoutPassword':
        options.url = urlData.urlWithoutPassword;
        noPass = true;
        break;

      case 'urlObject':
        options.url = urlData.urlObject;
        break;

      default:
        options[key] = testOptions[key];
    }
  });

  var tests = {
    topic: function() {
      return new AgentConnector(options);
    }
  };

  Object.keys(defaultOptions).forEach(function(key) {
    switch (key) {
      case 'agent':
        if (options.agent || options.socket) {
          tests['should have agent option'] = function(connector) {
            assert.strictEqual(connector.agent, testOptions.agent);
          }
        }
        break;

      case 'socket':
        tests['should have socket option'] = function(connector) {
          var socket;

          if (options.socket) socket = testOptions.socket;
          else if (options.url || options.secure) socket = https;
          else socket = http;

          assert.strictEqual(connector.socket, socket);
        }
        break;

      case 'maxSockets':
        tests['should have maxSockets option'] = function(connector) {
          var maxSockets = options.maxSockets || defaultOptions.maxSockets;
          assert.strictEqual(connector.maxSockets, maxSockets);
          if (!options.agent) assert.strictEqual(connector.agent.maxSockets, maxSockets);
        }
        break;

      case 'host':
        tests['should have host option'] = function(connector) {
          var host = options.host || options.url && urlData.hostname || defaultOptions.host;
          assert.strictEqual(connector.host, host);
          if (!options.agent) assert.strictEqual(connector.agent.host, host);
        }
        break;

      case 'port':
        tests['should have port option'] = function(connector) {
          var port = options.port || options.url && parseInt(urlData.port);
          if (!port) port = options.secure ? 443 : 80;
          assert.strictEqual(connector.port, port);
          if (!options.agent) assert.strictEqual(connector.agent.port, port);
        }
        break;

      case 'path':
        tests['should have path option'] = function(connector) {
          var path = options.path || options.url && urlData.pathname || defaultOptions.path;
          assert.strictEqual(connector.path, path);
        }
        break;

      case 'query':
        tests['should have query option'] = function(connector) {
          var query = options.query || options.url && urlData.query || defaultOptions.query;
          assert.deepEqual(connector.query, query)
        };
        break;

      case 'hash':
        tests['should have hash option'] = function(connector) {
          var hash = options.hash || options.url && urlData.hash || defaultOptions.hash;
          assert.strictEqual(connector.hash, hash);
        };
        break

      case 'method':
        tests['should have method option'] = function(connector) {
          var method = options.method || defaultOptions.method;
          assert.strictEqual(connector.method, method);
        }
        break;

      case 'headers':
        tests['should have headers'] = function(connector) {
          var headers = {
            'Host': options.host || options.url && urlData.hostname || defaultOptions.host,
            'Connection': options.headers ? 'close' : 'close'
          };

          if (options.headers) headers['X-Test'] = 'true';

          if (options.auth) {
            headers['Authorization'] = testAuthHeader;
          } else if (options.url) {
            headers['Authorization'] = noPass ? urlData.headerWithoutPassword : urlData.header;
          }

          assert.deepEqual(connector.headers, headers);
        };
        break;

      case 'secure':
        tests['should have secure option'] = function(connector) {
          if (options.url || options.secure) assert.isTrue(connector.secure);
          else assert.isFalse(connector.secure);
        };
        break;

      case 'auth':
        if (options.auth) {
          tests['should have auth option'] = function(connector) {
            assert.deepEqual(connector.auth, testOptions.auth);
            assert.strictEqual(connector.headers['Authorization'], testAuthHeader);
          };
        } else if (options.url) {
          tests['should have auth option'] = function(connector) {
            var auth = { username: urlData.auth.username }
              , header = noPass ? urlData.headerWithoutPassword : urlData.header;
            if (!noPass) auth.password = urlData.auth.password;
            assert.deepEqual(connector.auth, auth);
            assert.strictEqual(connector.headers['Authorization'], header);
          };
        } else {
          tests['should not have auth option'] = function(connector) {
            assert.isUndefined(connector.auth);
            assert.isUndefined(connector.headers['Authorization']);
          };
        }
        break;

      default:
        throw new Error('Unknown test option: ' + key);
    }
  });

  return tests;
}

function shouldAcceptOptions() {
  var tests = {}
    , options = Object.keys(defaultOptions);

  options.push('url');

  combineOptions(options).forEach(function(options) {
    var text = 'when given ' + options.join(', ') + ' options';
    tests[text] = shouldHaveOptions(options);

    // test options
    if (~options.indexOf('url')) {
      var opt = options.slice();
      opt.splice(options.indexOf('url'), 1);

      options = opt.slice();
      options.push('urlWithoutPassword');
      text = 'when given ' + options.join(', ') + ' options';
      tests[text] = shouldHaveOptions(options);

      options = opt.slice();
      options.push('urlObject');
      text = 'when given ' + options.join(', ') + ' options';
      tests[text] = shouldHaveOptions(options);
    }
  });

  return tests;
}

function populateSuite(suite, text, tests) {
  var context, key;
  for (key in tests) {
    context = {}; context[key] = tests[key];
    suite.addBatch(context);
  }
}

function shouldBehaveLikeRequestMethod() {
  var tests = {};

  combineOptions([
    'absolutePath',
    'relativePath',
    'method',
    'headers',
    'data',
    'chunk',
    'callback'
  ]).forEach(function(setOptions) {
    var options = {}
      , absolutePath
      , relativePath
      , chunk
      , callback;

    setOptions.forEach(function(key) {
      switch (key) {
        case 'absolutePath':
          options.path = '/absolute';
          absolutePath = true;
          break;

        case 'relativePath':
          options.path = 'relative';
          relativePath = true;
          break;

        case 'data':
          options.data = 'Hello World!';
          break;

        case 'chunk':
          options.data = new EventEmitter;
          chunk = true;
          break;

        case 'callback':
          callback = sinon.stub();
          break;

        default:
          options[key] = testOptionsTemplate[key];
      }
    });

    if (!options.data && chunk || absolutePath && relativePath) return;

    var context = {
      topic: function() {
        var request = new EventEmitter
          , socket = { request: sinon.stub().returns(request) };

        merge(request, { write: sinon.stub(), end: sinon.stub() });

        var connector = new AgentConnector({ socket: socket, agent: {} })
          , requestSpy = sinon.spy(connector, 'request')
          , onSpy = sinon.spy(request, 'on');

        if (!Object.keys(options).length) {
          if (callback) connector.request(callback);
          else connector.request();
        } else {
          if (callback) connector.request(options, callback);
          else connector.request(options);
        }

        if (chunk) {
          options.data.emit('data', 'Hello ');
          options.data.emit('data', 'World!');
          options.data.emit('end');
        }

        this.callback(null, connector, requestSpy, request, onSpy)
      },
      'should call socket.request()': function(err, connector) {
        assert.isTrue(connector.socket.request.calledOnce);
      },
      'should call socket.request() with options': function(err, connector) {
        var socketOptions = connector.socket.request.getCall(0).args[0]
          , path = connector.path
          , method = options.method || connector.method
          , headers = merge({}, connector.headers, options.headers || {});

        if (absolutePath) {
          path = '/absolute';
        } else if (relativePath) {
          path += '/relative';
        }

        if (chunk) headers['Transfer-Encoding'] = 'chunked';
        else if (options.data) headers['Content-Length'] = Buffer.byteLength('Hello World!');

        assert.strictEqual(socketOptions.agent, connector.agent);
        assert.strictEqual(socketOptions.host, connector.host);
        assert.strictEqual(socketOptions.port, connector.port);
        assert.strictEqual(socketOptions.path, path);
        assert.strictEqual(socketOptions.method, method);
        assert.deepEqual(socketOptions.headers, headers);
      },
      'should return the return value of socket.request()': function(err, connector, requestSpy, request) {
        assert.strictEqual(requestSpy.getCall(0).returnValue, request);
      },
      'should call request.end()': function(err, connector, spy, request) {
        assert.isTrue(request.end.calledOnce);
      }
    };

    if (callback) {
      context['should assign callback to events'] = function(err, connector, requestSpy, request, onSpy) {
        assert.isTrue(onSpy.calledWith('response'));
        assert.isTrue(onSpy.calledWith('error'));
      };
      context['when emitting a response'] = {
        topic: function(connector, requestSpy, request, onSpy) {
          var response = {}; request.emit('response', response); return response;
        },
        'should call the callback with the response': function(response) {
          assert.isTrue(callback.calledWith(null, response));
        }
      };
      context['when emitting an error'] = {
        topic: function(connector, requestSpy, request, onSpy) {
          var error = {}; request.emit('error', error); return error;
        },
        'should call the callback with the error': function(error) {
          assert.isTrue(callback.calledWith(error));
        }
      };
    }

    if (chunk) {
      context['should write chunk data'] = function(err, connector, spy, request) {
        assert.isTrue(request.write.calledTwice);
        assert.strictEqual(request.write.getCall(0).args[0], 'Hello ');
        assert.strictEqual(request.write.getCall(1).args[0], 'World!');
      };
    } else if (options.data) {
      context['should write data'] = function(err, connector, spy, request) {
        assert.isTrue(request.write.calledOnce);
        assert.strictEqual(request.write.getCall(0).args[0], options.data);
      };
    }

    tests['with ' + setOptions.join(', ') + ' options'] = context;
  });

  return tests;
}

function combineOptions(keys) {
  var sets = [[]]
    , i, len, options, entry, key;

  while (key = keys.shift()) {
    i = 0; len = sets.length;
    while (i < len) {
      options = sets[i++];
      entry = options.slice();
      entry.push(key);
      sets.push(entry);
    }
  }

  return sets;
}

/**
 * Vows tests.
 */

var suite = vows.describe('AgentConnector');

populateSuite(suite, 'AgentConnector', shouldAcceptOptions());
populateSuite(suite, 'AgentConnector.request()', shouldBehaveLikeRequestMethod());

suite.addBatch({
  'AgentConnector.close()': {
    topic: function() {
      var socket = { end: sinon.stub() };

      var connector = new AgentConnector({
        agent: {
          sockets: [socket, socket, socket, socket]
        }
      });

      connector.close();

      return connector;
    },
    'should call agent.sockets[].end()': function(connector) {
      var sockets = connector.agent.sockets;
      assert.strictEqual(sockets[0].end.callCount, sockets.length);
    },
    'when given callback option': {
      topic: function(connector) {
        var callback = sinon.stub();
        connector.close(callback);
        this.callback(null, connector, callback);
      },
      'should call callback': function(err, connector, callback) {
        assert.isTrue(callback.calledOnce);
      }
    }
  }
}).export(module);
