/*!

    Copyright 2011 Michael Phan-Ba

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 */


/** Module dependencies. */

var EventEmitter = require('events').EventEmitter
  , http = require('http')
  , https = require('https')
  , querystring = require('querystring')
  , url = require('url');

var cradle = require('../../cradle')
  , Connector = require('../connector').Connector;


/** Cluster connection factory. */

var ClusterConnector = exports.ClusterConnector = function(options) {
  var servers = {}
    , clusters = [];

  var i = 0
    , len = options.servers.length
    , server
    , serverOptions
    , priority
    , priorityGroup;

  while (i < len) {
    serverOptions = options.servers[i++];
    server = new Connector(serverOptions);
    priority = serverOptions.priority || 0;
    if (!servers[priority]) {
      priorityGroup = servers[priority] = [];
      priorityGroup.next = 0;
    } else {
      priorityGroup = servers[priority];
    }
    priorityGroup.push(server);
  };

  var keys = [];
  for (var key in servers) keys.push(key);
  keys.sort();

  if (!keys.length) throw new Error('No clusters configured')

  for (i = 0, len = keys.length; i < len; i++) {
    clusters[i] = servers[keys[i]];
  }

  this.clusters = clusters;
  this.clusters.next = 0;
};


/** Default options. */

ClusterConnector.prototype = {

  /** Minimum milliseconds to backoff before retrying higher-priority
      clusters.
   */

  minBackoff: 1000,

  /** Maximum milliseconds to backoff before retrying higher-priority
      clusters.
   */

  maxBackoff: 60000

};


/** Service a request.

    See `Connector` for options.

    @param {Object} options
    @param {Function} (optional) callback
    @return {ClientRequest}
    @api public
 */

ClusterConnector.prototype.request = function(options, callback) {
  return this._request(options, callback, new EventEmitter, this._getServer());
};

ClusterConnector.prototype._request = function(options, callback, promise, server, chunks, end) {
  if (!server) return promise.emit('error', new Error('system failure'));

  var request = server.request(options, callback)
    , bufferWrite = options && options.bufferWrite
    , self = this;

  request.on('continue', function() {
    promise.emit('continue');
  });

  request.on('response', function(response) {
    promise.emit('response', response);
  });

  request.on('error', function(err) {

    // Try alternate servers
    if (// This server is dead
        err.code === 'ECONNREFUSED' &&
        // Is there a next alternate server to use?
        (server = self._getServer(true)))
    {
      promise.emit('retry', err);
      return self._request(options, callback, promise, server, chunks, end);
    }

    promise.emit('error', err);
  });

  if (chunks) {
    for (var i = 0, chunk; chunk = chunks[i]; ++i) {
      request.write(chunk[0], chunk[1]);
    }
  } else {
    promise.write = function(chunk, encoding) {
      if (bufferWrite) {
        if (!chunks) chunks = [[chunk, encoding]];
        else chunks.push([chunk, encoding]);
      }
      request.write(chunk, encoding);
    };
  }

  if (end) {
    bufferWrite ? request.end(end[0], end[1]) : request.end();
  } else {
    promise.end = function(data, encoding) {
      end = bufferWrite ? [data, encoding] : true;
      request.end(data, encoding);
    };
  }

  promise.abort = function() {
    request.abort();
  };

  return promise;
};

ClusterConnector.prototype._getServer = function(serverFail) {
  var cluster = this.clusters[this.clusters.next]
    , self = this;

  if (!cluster) return;

  var clusterSize = cluster.length
    , server = cluster[cluster.next];

  if (serverFail) {
    (function(server) {
      if (!server.backoff) {
        server.backoff = self.minBackoff;
      } else {
        if ((server.backoff <<= 1) > self.maxBackoff) {
          server.backoff = self.maxBackoff;
        }
      }
      server.retryTimer = setTimeout(function() {
        delete server.retryTimer;
      }, server.backoff);
    })(server);
  } else {
    delete server.backoff;
  }

  while (clusterSize--) {
    server = cluster[++cluster.next] || cluster[cluster.next = 0];
    if (!server.retryTimer) break;
    server = null;
  }

  if (!server && this.clusters[this.clusters.next + 1]) {
    ++this.clusters.next;

    (function(cluster) {
      if (!cluster.backoff) {
        cluster.backoff = self.minBackoff;
      } else {
        if ((cluster.backoff <<= 1) > self.maxBackoff) {
          cluster.backoff = self.maxBackoff;
        }
      }
      cluster.retryTimer = setTimeout(function() {
        --self.clusters.next;
        delete cluster.retryTimer;
      }, cluster.backoff);
    })(cluster);

    return this._getServer();
  }

  return server;
};
