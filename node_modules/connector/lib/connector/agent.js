/*!

    Copyright 2011 Michael Phan-Ba

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 */


/** Module dependencies. */

var http = require('http')
  , https = require('https')
  , url = require('url');

var util = require('./util');


/** HTTP agent connector.

    @param {Object|String} [options] Options or URL.
      @param {String} [options.url] Configure using URL. Overridden by itemized
        options.
      @param {Agent} [options.agent] HTTP agent. If not given, created
        automatically from `socket`.
      @param {module} [options.socket] HTTP socket. Defaults to `https` if
        `options.secure` is true, `http` otherwise.
      @param {Integer} [options.maxSockets=8] Maximum number of sockets for
        newly created HTTP agents.
      @param {String} [options.host="127.0.0.1"] HTTP host. Sets the `Host`
      	header in `options.headers`.
      @param {String} [options.port] HTTP port. Defaults to `443` when
        `options.secure` is true, `80` otherwise
      @param {String} [options.path=""] HTTP path prefix to prepend to
      	relative request paths.
      @param {Object} [options.query] HTTP query parameters.
      @param {String} [options.hash] HTTP hash component.
      @param {String} [options.method="GET"] HTTP method.
      @param {Object} [options.headers] HTTP headers. The `Host` header has
      	a default value of `options.host`. The `Connection` header has a
      	default value of `keep-alive`. If `options.auth` is provided, the
      	`Authorization` header is also populated.
      @param {Object} [options.auth] HTTP basic authentication. If at least
      	`options.auth.username` is given, populates the `Authorization`
      	header in `options.headers`.
        @param {String} [options.username] Username.
        @param {String} [options.password] Password.
      @param {Boolean} [options.secure=false] Use secure connection.
 */

var AgentConnector = exports.AgentConnector = function(options) {

  // Support URL string argument
  options = typeof options === 'string' ? { url: options } : options || {};

  // Parse URL
  if (options.url) {
    var parts = typeof options.url === 'object' ? options.url : url.parse(options.url, true);
    if (parts.protocol === 'https:') this.secure = true;
    if (parts.auth) {
      if (typeof parts.auth === 'object') {
        this.auth = parts.auth;
      } else {
        var loc = parts.auth.indexOf(':');
        if (~loc) {
          this.auth = { username: decodeURIComponent(parts.auth.substr(0, loc)) };
          if (++loc < parts.auth.length) this.auth.password = decodeURIComponent(parts.auth.substr(loc));
        } else {
          this.auth = { username: decodeURIComponent(parts.auth) };
        }
      }
    }
    if (parts.hostname) this.host = parts.hostname;
    if (parts.port) this.port = parseInt(parts.port);
    if (parts.pathname) this.path = parts.pathname;
    if (parts.query) this.query = parts.query;
    if (parts.hash) this.hash = parts.hash[0] === '#' ? parts.hash.substr(1) : parts.hash;
  }

  // Options
  if (options.host) this.host = options.host;
  if (options.port) this.port = parseInt(options.port);
  if (options.path) this.path = options.path;
  if (options.query) this.query = options.query;
  if (options.hash) this.hash = options.hash;
  if (options.method) this.method = options.method;
  if (options.secure) this.secure = true;
  if (options.auth) this.auth = options.auth;

  // Choose HTTP socket
  this.socket = options.socket || (this.secure ? https : http);

  // Choose HTTPS port
  if (options.port) this.port = options.port;
  else if (!this.port) this.port = this.secure ? 443 : 80;

  // Create or use custom agent
  if (options.maxSockets) this.maxSockets = options.maxSockets;
  if (options.agent) {
    this.agent = options.agent;
  } else {
    this.agent = new(this.socket.Agent)({
      host: this.host,
      port: this.port
    });
    this.agent.maxSockets = this.maxSockets;
  }

  // Set default headers
  this.headers = util.merge({
    'Host': this.host,
    'Connection': 'close'
  }, options.headers || {});

  // Set basic authentication header
  if (this.auth && this.auth.username) {
    var username = this.auth.username
      , password = this.auth.password
      , auth = password ? [username, password].join(':') : username;
    this.headers['Authorization'] = 'Basic ' + new Buffer(auth).toString('base64');
  }
};


/** Default options. */

AgentConnector.prototype = {


  /** Max HTTP agent sockets. */

  maxSockets: 8,


  /** Remote host. */

  host: '127.0.0.1',


  /** HTTP path prefix. */

  path: '',


  /** HTTP method. */

  method: 'GET',


  /** Use secure connection. */

  secure: false

};


/** Service a request.

    @param {Object} [options] Options.
      @param {String} [options.path=this.path] HTTP path. If the path does
        not begin with `/`, it is prefixed with `this.path`.
      @param {Object} [options.query=this.query] HTTP query options. These
        entries override query entries from `this.query`.
      @param {Object} [options.hash=this.hash] HTTP hash component.
      @param {String} [options.method=this.method] HTTP method.
      @param {Object} [options.headers=this.headers] HTTP headers. These
        headers override headers from `this.headers`. Depending on
        constructor and other method options, may have default values for
        the headers `Host`, `Connection`, `Authorization`, and
        `Transfer-Encoding`.
      @param {String|EventEmitter} [options.data] Request body. When using
        an `EventEmitter`: emit the `data` event to send a chunk of data;
        emit the `end` event to end the request. Using an `EventEmitter`
        also sets the `Transfer-Encoding` header `chunked`. Override
        `Transfer-Encoding` using the `headers` option if this is
        undesirable.
    @param {Function} [callback] Callback function.
      @param {Error|null} callback.error Error or `null` on success.
      @param {ClientResponse} callback.response ClientResponse object.
    @return {ClientRequest}
 */

AgentConnector.prototype.request = function(options, callback) {
  if (typeof options !== 'object') {
    callback = options;
    options = null;
  }

  options = options || {};

  var path = this.path
    , query = options.query || this.query
    , hash = options.hash || this.hash
    , method = options.method || this.method
    , headers = {}
    , data = options.data;

  if (options.path) {
    if (options.path[0] === '/') {
      path = options.path;
    } else {
      path += '/' + options.path;
    }
  }

  if (query) query = util.merge({}, this.query || {}, options.query || {});

  path = url.format({
    pathname: path,
    query: query,
    hash: hash
  });

  if (data) {
    if (data.on) headers['Transfer-Encoding'] = 'chunked';
    else headers['Content-Length'] = Buffer.byteLength(data);
  }

  headers = util.merge({}, this.headers, headers, options.headers || {});

  var request = this.socket.request({
    agent: this.agent,
    host: this.host,
    port: this.port,
    path: path,
    method: method.toUpperCase(),
    headers: headers
  });

  if (data) {
    if (data.on) {
      data.on('data', request.write.bind(request));
      data.on('end', request.end.bind(request));
    } else {
      request.write(data, 'utf8');
      request.end();
    }
  } else {
    request.end();
  }

  if (callback) {
    request.on('response', callback.bind(null, null));
    request.on('error', callback);
  }

  return request;
};


/** Close underlying connections.

    @param {Function} [callback] Callback function.
      @param {Error|null} callback.error Error or `null` on success.
 */

AgentConnector.prototype.close = function(callback) {
  this.agent.sockets.forEach(function(socket) { socket.end() });
  callback && callback();
};
